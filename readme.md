# goit-algo-hw-07

# Домашнє завдання до теми “Дерева та балансування”

## Підготовчий етап: Реалізація Двійкового Дерева Пошуку (BST)
Для виконання перших трьох завдань, нам потрібна базова реалізація двійкового дерева пошуку (BST).  Я створив простий клас `Node` для представлення вузла та функцію `insert` для побудови дерева, спираючись на матеріали курсу.

```python
# Клас, що представляє окремий вузол у Двійковому Дереві Пошуку (BST)
class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

# Функція для вставки нового вузла з заданим ключем у BST
def insert(root, key):
    # Якщо дерево порожнє, повертаємо новий вузол
    if root is None:
        return Node(key)
    else:
        # Інакше, рекурсивно спускаємося по дереву
        if key < root.val:
            root.left = insert(root.left, key)
        else:
            root.right = insert(root.right, key)
    return root

# Створення тестового дерева для завдань 1, 2, 3
root = None
keys = [20, 8, 22, 4, 12, 10, 14, 25, 30]
for key in keys:
    root = insert(root, key)
```

------------

## Завдання 1: Пошук найбільшого значення в дереві
**Опис:** Написати алгоритм (функцію), який знаходить найбільше значення у двійковому дереві пошуку. 

### Рішення:
Згідно з властивостями двійкового дерева пошуку, найбільший елемент завжди знаходиться у крайньому правому вузлі. Тому ми починаємо з кореня і рухаємось вправо, доки не досягнемо останнього вузла.

```python
def find_max(root):
    """
    Функція для знаходження найбільшого значення в BST.
    Рухається до крайнього правого вузла.
    Додано обробку порожнього дерева.
    """
    # ПЕРЕВІРКА: Якщо дерево порожнє, неможливо знайти максимум.
    if not root:
        return None  # Повертаємо None як індикатор відсутності значення

    current = root
    while(current.right is not None):
        current = current.right
    return current.val
```

### Тестування Завдання 1:

```python
# Виклик функції та вивід результату
max_value = find_max(root)
print(f"Найбільше значення в дереві: {max_value}")

# Очікуваний результат: Найбільше значення в дереві: 30
```
### Виведення:

`Найбільше значення в дереві: 30`

**Результат:** Код виконується і функція успішно знаходить найбільше значення в дереві.

------------

## Завдання 2: Пошук найменшого значення в дереві
**Опис:** Написати алгоритм (функцію), який знаходить найменше значення у двійковому дереві пошуку. 

### Рішення:
Аналогічно до пошуку максимуму, найменший елемент у BST завжди є крайнім лівим вузлом. Алгоритм починається з кореня і рухається вліво до кінця.

```python
def find_min(root):
    """
    Функція для знаходження найменшого значення в BST.
    Рухається до крайнього лівого вузла.
    Додано обробку порожнього дерева.
    """
    # ПЕРЕВІРКА: Якщо дерево порожнє, неможливо знайти мінімум.
    if not root:
        return None # Повертаємо None як індикатор відсутності значення

    current = root
    while(current.left is not None):
        current = current.left
    return current.val
```

### Тестування Завдання 2:

```python
# Виклик функції та вивід результату
min_value = find_min(root)
print(f"Найменше значення в дереві: {min_value}")

# Очікуваний результат: Найменше значення в дереві: 4
```

### Виведення:

`Найменше значення в дереві: 4`

**Результат:** Код виконується і функція успішно знаходить найменше значення в дереві.

------------

## Завдання 3: Пошук суми всіх значень у дереві
**Опис:** Написати алгоритм (функцію), який знаходить суму всіх значень у двійковому дереві пошуку. 

### Рішення:
Для знаходження суми ми використаємо рекурсивний підхід. Сума всього дерева дорівнює значенню поточного вузла плюс суми значень його лівого та правого піддерев.

```python
def sum_all_values(root):
    """
    Функція для знаходження суми всіх значень у дереві.
    Використовує рекурсивний обхід.
    Базовий випадок рекурсії тепер є точкою виходу.
    """
    # БАЗОВИЙ ВИПАДОК РЕКУРСІЇ: Якщо вузол порожній, його сума дорівнює 0.
    if root is None:
        return 0
        
    return root.val + sum_all_values(root.left) + sum_all_values(root.right)
```

### Тестування Завдання 3:

```python
# Виклик функції та вивід результату
total_sum = sum_all_values(root)
print(f"Сума всіх значень у дереві: {total_sum}")

# Очікуваний результат: Сума всіх значень у дереві: 145 (20+8+22+4+12+10+14+25+30)
```

### Виведення:

`Сума всіх значень у дереві: 145`

**Результат:** Код виконується і функція успішно знаходить суму всіх значень у дереві.

------------

## Завдання 4 (необов'язкове): Система коментарів
**Опис:** Реалізувати ієрархічну структуру даних для системи коментарів з можливістю додавання, видалення та відображення відповідей. 

### Рішення:
Я реалізував клас `Comment`, який відповідає всім вимогам: зберігає текст, автора, список відповідей та статус видалення. Метод `display` рекурсивно виводить всю ієрархію з відповідними відступами.

```python
from typing import List, Type

class Comment:
    """
    Клас для представлення ієрархічної структури коментарів.
    Включає покращену обробку помилок та анотації типів.
    """
    def __init__(self, text: str, author: str):
        self.text: str = text
        self.author: str = author
        self.replies: List['Comment'] = []
        self.is_deleted: bool = False

    def add_reply(self, reply: 'Comment'):
        """
        Додає нову відповідь до коментаря.
        Викликає TypeError, якщо відповідь не є екземпляром класу Comment.
        """
        if not isinstance(reply, Comment):
            # Замість друку помилки генеруємо виняток
            raise TypeError("Відповідь має бути екземпляром класу Comment.")
        self.replies.append(reply)

    def remove_reply(self):
        """
        "М'яке видалення" коментаря: змінює текст та встановлює прапорець.
        Структура нащадків зберігається.
        """
        self.text = "Цей коментар було видалено."
        self.author = "" # Приховуємо автора
        self.is_deleted = True

    def display(self, level: int = 0):
        """
        Рекурсивно виводить коментар та всі його відповіді з відступами.
        """
        prefix = "    " * level
        if self.is_deleted:
            print(f"{prefix}{self.text}")
        else:
            print(f"{prefix}{self.author}: {self.text}")
        
        for r in self.replies:
            r.display(level + 1)
```

### Тестування Завдання 4:
**Відтворимо приклад, наведений в описі завдання.**

```python
# Створення коментарів
root_comment = Comment("Яка чудова книга!", "Бодя")
reply1 = Comment("Книга повне розчарування :(", "Андрій")
reply2 = Comment("Що в ній чудового?", "Марина")

# Додавання відповідей
root_comment.add_reply(reply1)
root_comment.add_reply(reply2)

# Вкладена відповідь
reply1_1 = Comment("Не книжка, а перевели купу паперу ні нащо...", "Сергій")
reply1.add_reply(reply1_1)

# "Видалення" коментаря Андрія
reply1.remove_reply()

print("--- Структура коментарів після видалення коментаря ---")
root_comment.display()

# Тестування обробки помилок
print("\n--- Тестування обробки помилок ---")
try:
    # Спроба додати відповідь неправильного типу
    root_comment.add_reply("Це не коментар, а просто рядок")
except TypeError as e:
    print(f"Успішно перехоплено помилку: {e}")
```

### Виведення:

```
--- Структура коментарів після видалення коментаря ---
Бодя: Яка чудова книга!
    Цей коментар було видалено.
        Сергій: Не книжка, а перевели купу паперу ні нащо...
    Марина: Що в ній чудового?

--- Тестування обробки помилок ---
Успішно перехоплено помилку: Відповідь має бути екземпляром класу Comment.
```

**Результат:** Код виконується і структура коментарів працює та відображається згідно з вимогами.

------------